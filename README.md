# №4 Ручное компилирование и запуск программы на C++

## Компиляция и запуск программы на C++

Скомпилируйте и запустите программу `hi.cpp`.

```bash
g++ hi.cpp
./a.out
```

Перечислите файлы, созданные в процессе компиляции и запуска программы.

```bash
ls -halp
```

## Компиляция с указанием выходного файла

Скомпилируйте программу `ola.cpp`, указав имя выходного файла `ola.exe`.

```bash
g++ ola.cpp -o ola.exe
./ola.exe
```

## Переместите файлы в директорию `build`.

```bash
mkdir -p build
mv a.out ola.exe build/
```

## Структура проекта

```bash
tree
```

## Структура исполняемого файла

Изучим структуру экзешника перечислив функции в нем.

```bash
nm build/ola.exe | grep " T "
```

Установим компилятор `clang` (вам не потребуется сохранять вывод данной команды в `execution.log`).

```bash
sudo apt install clang
```

Скомпилируем `ola.cpp` с помощью `clang`.

```bash
clang++ ola.cpp -o build/ola_clang.exe
./build/ola_clang.exe
```

Проверим его структуру.

```bash
nm build/ola_clang.exe | grep " T "
```

## Имена функций в C++

Компилируем `names.cpp`.

```bash
clang++ names.cpp -o build/names.exe
./build/names.exe
```

Посмотрим на имена функций в скомпилированном файле.

```bash
nm build/names.exe | grep " T "
```

## Совпадение имен функций

Расскомментируем строчку `// Ошибка компиляции` в `names.cpp` и попробуем скомпилировать снова.

```bash
clang++ names.cpp -o build/names.exe
```

Несмотря на то, что функция `bar` располагается в секции `extern "C"`, компилятор выдает ошибку о дублировании имен
функций.
Это происходит из-за того, что компилятор C++ не сможет отличить вызов такой функции внутри программы на C++.
Хотя физически в экзешнике эти функции получат разные имена (Какие?).

## Очистка директории

Проверим какие файлы присутствуют в проекте.

```bash
tree
```

Удалим директорию `build`.

```bash
rm -r build
```

Убедимся что остались только файлы исходного кода.

```bash
tree
```

## Сохранение вывода команд в файл

Сохраним вывод команды `ls -halp` в файл `execution.log`.

```bash
ls -halp >> execution.log
```

Проверим содержимое файла.

```bash
cat execution.log
```

Теперь необходимо заново выполнить всё задание, но при этом сохранить вывод всех команд в файл `execution.log`.

Обратим внимание, что необходимо модифицировать команду сохранения в лог, если мы хотим сохранить ошибки компиляции.

---

# Дополнительное упражнение (необязательно)

Скомпилируйте проект, используя `cmake`.

В качестве доказательства предоставьте вывод команты `tree -DF` в файле `files.txt` после сборки проекта.
